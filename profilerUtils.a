 INCLUDE 'Traps.a' INCLUDE 'Timer.a' INCLUDE 'Memory.a'            SEG    IMPORT ProfilerTimerFunction    EXPORT profilerEndlessLoopAddr:DATA    EXPORT profilerPCOffset:DATA    EXPORT profilerStackCrawlStopAddr:DATA    EXPORT profilerTimerTask:DATA    EXPORT profilerAppHeapStart:DATA    EXPORT profilerAppHeapEnd:DATAprofilerEndlessLoopAddr     DC.L 0profilerPCOffset     DC.W 0profilerStackCrawlStopAddr     DC.L 0profilerTimerTask     DS.B 24profilerAppHeapStart     DC.L 0profilerAppHeapEnd     DC.L 0            ProfilerFindPCOffset PROC EXPORT    ; d0: address to check in stack (used so we can easily run it through StripAddress)    ; d1: target address    ; d2: counter    ; a1: address of SP at start of function    ; a0: used for whatevs        lea profilerEndlessLoopAddr(PC), A0    move.l (A0), D0    cmpi.l #0, D0    bne.b ready        ; We're not ready to check the stack, so just prime the timer and return:    lea profilerTimerTask(PC), A0    move.l #1, D0    _PrimeTime    rts        ready:    _StripAddress    move.l D0, D1        move.l SP, A1    clr.l D2        loop_search_stack:        move.w (A1, D2.w), D0    andi.w #$FF, D0    cmpi.w #$1F, D0    bne.b noMatch        move.l (2, A1, D2.w), D0    _StripAddress    cmp.l D1, D0    bne.b noMatch        ; We got the offset, increment it by 2 to end the loop!    addq.w #2, D2        move.l (A1, D2.w), D0    addq.l #2, D0    move.l D0, (A1, D2)            lea profilerPCOffset(PC), A0    move.w D2, (A0)    rts        noMatch:    addq.w #2, D2    cmpi.w #$100, D2    blt.b loop_search_stack        ; Loop is over without finding anything:        lea profilerPCOffset(PC), A0    move.w (A0), D0    addq.w #1, (A0)    tst.w (A0)    beq.s end_loop_search_stack        ; Prime the timer to try again in 1 ms    lea profilerTimerTask(PC), A0    move.l #1, D0    _PrimeTime    rts        end_loop_search_stack:    ; We've tried too many times, so we break out of the endless loop    ; by replacing it with NOP and write -1 to profilerPCOffset to    ; indicate an error    lea profilerPCOffset(PC), A0    move.l #-1, (A0)        move.l D1, A1    move.w #$4E71, (A1)        finished:    rts    ENDP        ProfilerTimerFunctionShim PROC EXPORT    move.l SP, -(SP)    jsr ProfilerTimerFunction    addq.l #4, SP    rts    ENDP            ProfilerStackCrawl PROC EXPORT    ; d0: Used for whatever    ; d1: Stack crawl stop address    ; d2: Safe address range start    ; d3: Safe address range end    ; a0: Current A6 frame    ; a1: Output buffer address (and temporary storage at beginning)    ; a2: Output counter address    ; a3: End of buffer addressBuffer EQU 8Counter EQU 12EndOfBuffer EQU 16ErrorPtr EQU 20        ; Store old a6 before calling link    move.l (A6), A0        link A6, #0    movem.l D3/A2-A3, -(SP)        lea profilerAppHeapStart(PC), A1    move.l (A1), D2             ; Safe addr start    lea profilerAppHeapEnd(PC), A1    move.l (A1), D3             ; Safe addr end        lea profilerStackCrawlStopAddr(PC), A1    move.l (A1), D1             ; Stop addr        move.l ErrorPtr(A6), A1    clr.w (A1)                   ; Clear error indicator        move.l Buffer(A6), A1       ; Output buffer    move.l Counter(A6), A2      ; Output counter    move.l EndOfBuffer(A6), A3  ; End of buffer        clr.w (A2)        loop_stack_crawl:    move.l A0, D0    _StripAddress    move.l D0, A0        ; Hit null frame?    tst.l D0    beq.s end_loop_stack_crawl        ; Below safe address range?    cmp.l D2, D0    bcs.s bad_a6    ; Above safe address range?    cmp.l D3, D0    bcc.s bad_a6        ; Hit stop addr?    cmp.l 4(A0), D1    beq.s end_loop_stack_crawl        ; Hit end of buffer?    cmp.l A3, A1    bhs.s out_of_buffer        ; Too many frames?    cmpi.w #48, (A2)    bcc.s too_many_frames        move.l 4(A0), (A1)+        addq.w #1, (A2)        move.l (A0), A0    bra.s loop_stack_crawl        bad_a6:    move.l ErrorPtr(A6), A0    ; Set error indicator: hit bad A6 frame    move.w #3, (A0)    bra.s end_loop_stack_crawl        too_many_frames:    move.l ErrorPtr(A6), A0    ; Set error indicator: traversed too many frames    move.w #2, (A0)    bra.s end_loop_stack_crawl        out_of_buffer:    move.l ErrorPtr(A6), A0    ; Set error indicator: ran out of buffer    move.w #1, (A0)        end_loop_stack_crawl:    movem.l (SP)+, D3/A2-A3    unlk A6    rts    ENDP        END